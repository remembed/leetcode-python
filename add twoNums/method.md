题目概述：
给定一个整数数列，找出其中和为特定值的那两个数。
你可以假设每个输入都只会有一种答案，同样的元素不能被重用。

示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
所用到的命令：len：测量长度(比如说给一个列表，就能测量出列表中有几个数)
for x in range(n):

函数语法
range(start, stop[, step])

参数说明：
start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;
stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5;
step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1).


解题思路：

方法一：
当第一次看见这个题目时，定义一个n并测量其长度，用一个嵌套循环把nums列表把遍历两次，
这样就得到了两个数值，然后让第一次遍历的数x与给定数值(target)-第二次遍历的数值y作比较，
假如给定数值(target)-第一次遍历的值(nums[x])存在于nums(y)(第二次遍历得到的值)中，
则证明已找到这两个数，这时可以返回x,y

方法二：
用一个for循环，直接在里面查询target-nums[x]是否存在于nums列表中
index  索引，就是指定一个数值

方法三:
先创建一个空字典，然后依次把target-nums[x]的值存入字典，存入一个就跟nums[x+1]去比较，
字典中的key为target-nums[x],value为x，也就是nums[x]在nums列表中的索引位置。
当字典d中有nums[x+1]时，也就是target - nums[y] = nums[x+1] , y肯定是小于x+1的
(因为y是x+1之前循环过的数字),所以是 return y,x+1
